---
description: Agentic Trust & ERC-8004 Guidelines
globs: "**/*"
---

# Agentic Trust & ERC-8004

When working with the Agentic Trust library, ERC-8004, agent identity, reputation feedback, or validation:

-   **Reference Repository**: Always consult the official repository at [https://github.com/Agentic-Trust-Layer/agentic-trust](https://github.com/Agentic-Trust-Layer/agentic-trust) for the latest patterns, architecture, and implementation details.
-   **ERC-8092 Reference Repo (Associated Accounts)**: For ERC-8092 / Associated Accounts patterns (especially SC-DELEGATION), consult [https://github.com/Agentic-Trust-Layer/AssociatedAccounts](https://github.com/Agentic-Trust-Layer/AssociatedAccounts). In this repo, `apps/assoc-delegation` is the reference implementation for SC-DELEGATION (0x8004) proof construction + on-chain preflight via `validateSignedAssociationRecord`.
-   **Key Concepts**:
    -   **Agent Identity**: Veramo integration, DID management.
    -   **Reputation**: ERC-8004 feedback mechanisms.
    -   **Validation**: Agent validation workflows.
-   **ERC-8092 Sepolia Deployments (AssociatedAccounts - Updated 2026-01-23)**:
    - **AssociationsStore proxy**: `0x3d282c9E5054E3d819639246C177676A98cB0a1E`
    - **Implementation**: `0x1719f33e9F86d7a6AE905621C9dcAaa5e4214410`
    - **ProxyAdmin**: `0x0C16e38cf224FF95bD241aA8051Db3995C9a2A4E`
    - **SC Delegation Enforcer**: `0x107d5586Cb98C00d03B696d594eA15e6CE9F50d3`
    - **SC Delegation Verifier**: `0xAd762a8bBFafc2BeA41a2400F9bE5de8B5Fd1617`
    - **DelegationManager (configured)**: `0xdb9B1e94B5b69Df7e401DDbedE43491141047dB3`
-   **Agent Ownership Determination**:
    -   **Relationship**: Agent NFT is owned by Agent Account (account abstraction/smart contract), which is owned by an EOA (user wallet).
    -   **EOA Check**: If agent account has no bytecode, directly compare addresses.
    -   **Smart Contract Check**: Try ownership functions in order: `owner()`, `getOwner()`, `owners()[0]`.
    -   Always use case-insensitive comparison for Ethereum addresses.

    ```typescript
    // Determine if connected wallet owns an agent
    async function isWalletOwnerOfAgent(walletAddress: string, agentAccount: string, chainId: number): Promise<boolean> {
      const lowerWallet = walletAddress.toLowerCase();

      // Get bytecode to check if it's a contract
      const client = createPublicClient({ chain: getChain(chainId), transport: http(rpcUrl) });
      const code = await client.getBytecode({ address: agentAccount as Address });

      // EOA ownership: direct address comparison
      if (!code || code === '0x') {
        return agentAccount.toLowerCase() === lowerWallet;
      }

      // Smart contract ownership: try different patterns
      let controller: string | null = null;

      // Try ERC-173 owner() function
      try {
        controller = await client.readContract({
          address: agentAccount as Address,
          abi: [{ name: 'owner', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'address' }] }],
          functionName: 'owner',
        }) as string;
      } catch {}

      // Fallback: try getOwner() function
      if (!controller) {
        try {
          controller = await client.readContract({
            address: agentAccount as Address,
            abi: [{ name: 'getOwner', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'address' }] }],
            functionName: 'getOwner',
          }) as string;
        } catch {}
      }

      // Fallback: try owners() array function
      if (!controller) {
        try {
          const owners = await client.readContract({
            address: agentAccount as Address,
            abi: [{ name: 'owners', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'address[]' }] }],
            functionName: 'owners',
          }) as string[];
          controller = owners?.[0] ?? null;
        } catch {}
      }

      return Boolean(controller && controller.toLowerCase() === lowerWallet);
    }
    ```
-   **Sending UserOperations (Bundler)**:
    -   When sending a UserOperation via a bundler (Account Abstraction), always use the following pattern to ensure proper sponsorship and fee handling.
    -   Use `permissionless` to fetch gas prices if available.
    -   Use `bundlerClient.sendUserOperation` with the `account` object.
    -   Wait for the receipt using `waitForUserOperationReceipt`.

    ```typescript
    import { createBundlerClient, http } from 'viem/account-abstraction';
    // import { createPimlicoClient } from 'permissionless/clients/pimlico'; // Dynamic import preferred

    // 1. Create Bundler Client
    const bundlerClient = createBundlerClient({
      transport: http(bundlerUrl),
      paymaster: true, // Enable paymaster (SPONSORED)
      chain: chain,
      paymasterContext: { mode: 'SPONSORED' },
    });

    // 2. Fetch Gas Fees (Optional but recommended for Pimlico)
    let fee = {};
    try {
      const { createPimlicoClient } = await import('permissionless/clients/pimlico');
      const pimlico = createPimlicoClient({ transport: http(bundlerUrl) });
      const gas = await pimlico.getUserOperationGasPrice();
      fee = gas.fast || {};
    } catch (e) {
      // Fallback or ignore
    }

    // 3. Send UserOperation
    const userOpHash = await bundlerClient.sendUserOperation({
      account: accountClient,
      calls: calls, // Your array of calls
      ...fee,
    });

    // 4. Wait for Receipt
    const receipt = await bundlerClient.waitForUserOperationReceipt({ hash: userOpHash });
    ```

-   **Smart Accounts & Delegation (MetaMask Smart Accounts Kit)**:
    -   **Standard**: Smart accounts in this repo are created/used via `@metamask/smart-accounts-kit` (Hybrid implementation) and delegation is executed via `DelegationManager.encode.redeemDelegations(...)` with a `SessionPackage` (`aa`, `sessionAA`, `sessionKey`, `signedDelegation`).
    -   **Important**: Delegation-based transaction execution (redeeming delegation) is distinct from ERC‑1271 signature validation. Do not assume a delegated session key signature will pass `isValidSignature` unless the account is configured to be delegation-aware. Prefer an explicit `isValidSignature(hash, sig)` preflight when signature validity matters (e.g., ERC‑8092 `approverKeyType = 0x8002`).
-   **No Fallback Logic Rule**:
    -   **Principle**: If required data cannot be determined, fail early with a clear error message. Do not attempt actions with incomplete or guessed data.
    -   **Rationale**: Fallback logic can mask configuration issues and lead to incorrect behavior (e.g., sending transactions from the wrong account type, causing "Not authorized" errors).
    -   **Pattern**: When determining critical state (e.g., account type, ownership, mode), fetch the required data and validate it exists. If it's missing, throw an error explaining what's needed.
    -   **No “Try Multiple Encodings” Rule (Indexer/Discovery)**:
        - **Principle**: Do not query the discovery/indexer layer by trying multiple address encodings (e.g., `0x...`, lowercase, `11155111:0x...`, `eip155:...`, `did:pkh:...`) to “make it work”.
        - **Correct approach**: Determine the single canonical encoding the indexer stores for a field (schema + indexing config), and query using that encoding only.
        - **If it doesn’t match**: Throw an error that tells the developer exactly what’s misconfigured (indexer field mapping / normalization), and fix the deployment rather than adding heuristics in the client SDK.
    -   **Example - Validation Requests**:
        ```typescript
        // ❌ BAD: Silent fallback to default mode
        let requesterWalletOnChain: `0x${string}` | null = null;
        try {
          const r = await fetch(`/api/agents/${did}`);
          if (r.ok) {
            const d = await r.json();
            requesterWalletOnChain = resolvePlainAddress(d?.identityMetadata?.metadata?.agentWallet);
          }
        } catch {
          // best-effort - silently continues with null
        }
        const mode = isEoaOwnedRequester ? 'eoa' : 'smartAccount'; // Wrong if requesterWalletOnChain is null!

        // ✅ GOOD: Fail early if required data is missing
        const r = await fetch(`/api/agents/${did}`);
        if (!r.ok) {
          throw new Error(`Failed to fetch agent details: ${r.status}. Cannot determine validation request mode.`);
        }
        const d = await r.json();
        const metaWallet = d?.identityMetadata?.metadata?.agentWallet ?? null;
        if (!metaWallet) {
          throw new Error(`Agent has no on-chain agentWallet. Cannot determine validation request mode. The agent must have its agentWallet set on-chain.`);
        }
        const requesterWalletOnChain = resolvePlainAddress(metaWallet);
        if (!requesterWalletOnChain) {
          throw new Error(`Invalid agentWallet format: ${metaWallet}. Cannot determine validation request mode.`);
        }
        const mode = isEoaOwnedRequester ? 'eoa' : 'smartAccount'; // Now guaranteed to be correct
        ```
    -   **When to Apply**: Use this rule for any operation that requires on-chain state to determine the correct execution path (e.g., account type detection, ownership checks, mode selection).
