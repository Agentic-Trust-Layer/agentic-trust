---
description: Agentic Trust & ERC-8004 Guidelines
globs: "**/*"
---

# Agentic Trust & ERC-8004

When working with the Agentic Trust library, ERC-8004, agent identity, reputation feedback, or validation:

-   **Reference Repository**: Always consult the official repository at [https://github.com/Agentic-Trust-Layer/agentic-trust](https://github.com/Agentic-Trust-Layer/agentic-trust) for the latest patterns, architecture, and implementation details.
-   **Key Concepts**:
    -   **Agent Identity**: Veramo integration, DID management.
    -   **Reputation**: ERC-8004 feedback mechanisms.
    -   **Validation**: Agent validation workflows.
-   **Agent Ownership Determination**:
    -   **Relationship**: Agent NFT is owned by Agent Account (account abstraction/smart contract), which is owned by an EOA (user wallet).
    -   **EOA Check**: If agent account has no bytecode, directly compare addresses.
    -   **Smart Contract Check**: Try ownership functions in order: `owner()`, `getOwner()`, `owners()[0]`.
    -   Always use case-insensitive comparison for Ethereum addresses.

    ```typescript
    // Determine if connected wallet owns an agent
    async function isWalletOwnerOfAgent(walletAddress: string, agentAccount: string, chainId: number): Promise<boolean> {
      const lowerWallet = walletAddress.toLowerCase();

      // Get bytecode to check if it's a contract
      const client = createPublicClient({ chain: getChain(chainId), transport: http(rpcUrl) });
      const code = await client.getBytecode({ address: agentAccount as Address });

      // EOA ownership: direct address comparison
      if (!code || code === '0x') {
        return agentAccount.toLowerCase() === lowerWallet;
      }

      // Smart contract ownership: try different patterns
      let controller: string | null = null;

      // Try ERC-173 owner() function
      try {
        controller = await client.readContract({
          address: agentAccount as Address,
          abi: [{ name: 'owner', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'address' }] }],
          functionName: 'owner',
        }) as string;
      } catch {}

      // Fallback: try getOwner() function
      if (!controller) {
        try {
          controller = await client.readContract({
            address: agentAccount as Address,
            abi: [{ name: 'getOwner', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'address' }] }],
            functionName: 'getOwner',
          }) as string;
        } catch {}
      }

      // Fallback: try owners() array function
      if (!controller) {
        try {
          const owners = await client.readContract({
            address: agentAccount as Address,
            abi: [{ name: 'owners', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ type: 'address[]' }] }],
            functionName: 'owners',
          }) as string[];
          controller = owners?.[0] ?? null;
        } catch {}
      }

      return Boolean(controller && controller.toLowerCase() === lowerWallet);
    }
    ```
-   **Sending UserOperations (Bundler)**:
    -   When sending a UserOperation via a bundler (Account Abstraction), always use the following pattern to ensure proper sponsorship and fee handling.
    -   Use `permissionless` to fetch gas prices if available.
    -   Use `bundlerClient.sendUserOperation` with the `account` object.
    -   Wait for the receipt using `waitForUserOperationReceipt`.

    ```typescript
    import { createBundlerClient, http } from 'viem/account-abstraction';
    // import { createPimlicoClient } from 'permissionless/clients/pimlico'; // Dynamic import preferred

    // 1. Create Bundler Client
    const bundlerClient = createBundlerClient({
      transport: http(bundlerUrl),
      paymaster: true, // Enable paymaster (SPONSORED)
      chain: chain,
      paymasterContext: { mode: 'SPONSORED' },
    });

    // 2. Fetch Gas Fees (Optional but recommended for Pimlico)
    let fee = {};
    try {
      const { createPimlicoClient } = await import('permissionless/clients/pimlico');
      const pimlico = createPimlicoClient({ transport: http(bundlerUrl) });
      const gas = await pimlico.getUserOperationGasPrice();
      fee = gas.fast || {};
    } catch (e) {
      // Fallback or ignore
    }

    // 3. Send UserOperation
    const userOpHash = await bundlerClient.sendUserOperation({
      account: accountClient,
      calls: calls, // Your array of calls
      ...fee,
    });

    // 4. Wait for Receipt
    const receipt = await bundlerClient.waitForUserOperationReceipt({ hash: userOpHash });
    ```
-   **No Fallback Logic Rule**:
    -   **Principle**: If required data cannot be determined, fail early with a clear error message. Do not attempt actions with incomplete or guessed data.
    -   **Rationale**: Fallback logic can mask configuration issues and lead to incorrect behavior (e.g., sending transactions from the wrong account type, causing "Not authorized" errors).
    -   **Pattern**: When determining critical state (e.g., account type, ownership, mode), fetch the required data and validate it exists. If it's missing, throw an error explaining what's needed.
    -   **Example - Validation Requests**:
        ```typescript
        // ❌ BAD: Silent fallback to default mode
        let requesterWalletOnChain: `0x${string}` | null = null;
        try {
          const r = await fetch(`/api/agents/${did}`);
          if (r.ok) {
            const d = await r.json();
            requesterWalletOnChain = resolvePlainAddress(d?.identityMetadata?.metadata?.agentWallet);
          }
        } catch {
          // best-effort - silently continues with null
        }
        const mode = isEoaOwnedRequester ? 'eoa' : 'smartAccount'; // Wrong if requesterWalletOnChain is null!

        // ✅ GOOD: Fail early if required data is missing
        const r = await fetch(`/api/agents/${did}`);
        if (!r.ok) {
          throw new Error(`Failed to fetch agent details: ${r.status}. Cannot determine validation request mode.`);
        }
        const d = await r.json();
        const metaWallet = d?.identityMetadata?.metadata?.agentWallet ?? null;
        if (!metaWallet) {
          throw new Error(`Agent has no on-chain agentWallet. Cannot determine validation request mode. The agent must have its agentWallet set on-chain.`);
        }
        const requesterWalletOnChain = resolvePlainAddress(metaWallet);
        if (!requesterWalletOnChain) {
          throw new Error(`Invalid agentWallet format: ${metaWallet}. Cannot determine validation request mode.`);
        }
        const mode = isEoaOwnedRequester ? 'eoa' : 'smartAccount'; // Now guaranteed to be correct
        ```
    -   **When to Apply**: Use this rule for any operation that requires on-chain state to determine the correct execution path (e.g., account type detection, ownership checks, mode selection).
